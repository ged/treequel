---
title: Introduction
layout: intro
tagline: An honest LDAP library.
index: 1
filters:
  - erb
  - links
  - examples
  - editorial
  - api
  - textile
example_prelude: |-
  require 'treequel'
  dir = Treequel.directory
---

<div id="auto-toc"></div>

This is a manual for *Treequel*, a Ruby library that is intended to make interacting with an LDAP directory natural and easy without trying to make it behave like a relational database. It's built on top of "Ruby-LDAP":http://ruby-ldap.sourceforge.net/, so if you don't already have that installed you'll need to install it (<code>gem install ruby-ldap</code> should work for modern versions of Ruby), and you'll need to have access to an LDAP server, of course. 

h2(#connecting). Connecting to a Directory

Once those things are done, you can fire Treequel up via IRb and get a <?api Treequel::Directory ?> object to play around with:

<?example { language: irb, caption: "Fetching a directory." } ?>
$ irb -rtreequel -rubygems
irb> dir = Treequel.directory
# => #<Treequel::Directory:0x69cbac localhost:389 (not connected) base="dc=acme,dc=com", bound as=anonymous, schema=(schema not loaded)>
<?end?>

The @.directory@ method has some reasonable defaults, so if your directory is running on localhost, you want to connect using @TLS@ on the default port, and bind anonymously, this will be all you need. 

For anything other than testing, though, it's likely you'll want to control the connection parameters a bit more than that. There are two options for doing this: via an "LDAP URL":http://tools.ietf.org/html/rfc4516, or with a @Hash@ of options.

h3(#connect-ldap-url). Connecting With an LDAP URL

The LDAP URL format can contain quite a lot of information, but @Treequel::Directory@ only uses the _scheme_, _host_, _port_, and _base DN_ parts:

<?example { language: irb, caption: "Fetching a directory by URL." } ?>
irb> dir = Treequel.directory( 'ldap://ldap.andrew.cmu.edu/dc=cmu,dc=edu' )
# => #<Treequel::Directory:0x4f052e ldap.andrew.cmu.edu:389 (not connected) base="dc=cmu,dc=edu", bound as=anonymous, schema=(schema not loaded)>
<?end?>

You may omit the base <abbr title="Distingished Name">DN</abbr> in the URL if your environment only has one top level base (or you don't know it!) Treequel will use the first base DN it finds from the server's advertised "namingContexts":http://tools.ietf.org/html/rfc4512#section-5.1.2 by default.

It will also use the user and password from a ==<code>user:pass@host</code>==-style URL, if present, and use them to immediately bind to the directory. See "the section on binding":#binding for details.

h3(#connect-options-hash). Connecting With an Options Hash

Creating a directory with an options hash allows more fine-grained control over the connection and binding parameters. It's the same as the hash supported by <?api Treequel::Directory ?>'s constructor:

- @:host@ := The LDAP host to connect to.
- @:port@ := The port to connect to.
- @:connect_type@ := The type of connection to establish. Must be one of @:plain@, @:tls@, or @:ssl@.
- @:base_dn@ := The base DN of the directory.
- @:bind_dn@ := The DN of the user to bind as.
- @:pass@ := The password to use when binding.

Any values which you don't provide will default to the values in @Treequel::Directory::DEFAULT_OPTIONS@.

<?example { language: irb, caption: "Fetching a directory with an options hash." } ?>
irb> dir = Treequel.directory( :host => 'localhost', :base_dn => 'dc=acme,dc=com' )
# => => #<Treequel::Directory:0x4f2586 localhost:389 (not connected) base="dc=acme,dc=com",    bound as=anonymous, schema=(schema not loaded)>
<?end?>

h3(#mixing-url-and-options-hash). Connecting with a URL and an Options Hash

You can also mix the two connection styles, allowing you to still use a compact URL, but set the @connection_type@ explicitly, e.g.:

<?example { language: irb, caption: "Using both a URL and options." } ?>
irb> dir = Treequel.directory( 'ldap://localhost/dc=acme,dc=com', :connect_type => :plain )
# => #<Treequel::Directory:0x4a0844 localhost:389 (not connected) base="dc=acme,dc=com",    bound as=anonymous, schema=(schema not loaded)>
<?end?>

h3(#connecting-with-system-settings). Connecting With System Settings

Very often, the host you're running on will already be using LDAP for something else, so it might not make sense to configure the connection again when you've already got all the information you need in the system settings.

Treequel supports using LDAP system settings to create new <?api Treequel::Directory ?> objects, too, using either OpenLDAP or 'nss_ldap' style configurations. To do this, call @Treequel.directory_from_config@ with the path to the config file you want to load:

<?example { language: irb, caption: "Load an OpenLDAP config file." } ?>
irb> Treequel.directory_from_config( '/usr/local/etc/openldap/ldap.conf' )
# => #<Treequel::Directory:0x4078db0c ldap.acme.com:389 (not connected) base_dn="dc=acme,dc=com", bound as=anonymous, schema=(schema not loaded)>
<?end?>

Or, just omit the argument and Treequel will search a bunch of common paths[1] for a config file and load the first one it finds:

<?example { language: irb, caption: "Load the config from a common path." } ?>
irb> Treequel.log.level = Logger::INFO
# => 1
irb> Treequel.directory_from_config
[2010-08-20 17:04:40.648875 41003/main]  INFO -- Searching common paths for ldap.conf
[2010-08-20 17:04:40.650592 41003/main]  INFO -- Reading config options from /etc/openldap/ldap.conf...
# => #<Treequel::Directory:0x4078db0c ldap.acme.com:389 (not connected) base_dn="dc=acme,dc=com", bound as=anonymous, schema=(schema not loaded)>
<?end?>

It also supports overriding elements of the LDAP configuration via OpenLDAP-style environment variables, too:

<?example { language: irb, caption: "Override the configured host to connect to the master." } ?>
irb> ENV['LDAPHOST'] = 'ldap-master.acme.com'
# => "ldap-master.acme.com"
irb> Treequel.directory_from_config( '/etc/openldap/ldap.conf' )
[2010-08-20 17:19:57.686113 41432/main]  INFO -- Reading config options from /etc/openldap/ldap.conf...
# => #<Treequel::Directory:0x4078c266 ldap-master.acme.com:389 (not connected) base_dn="dc=acme,dc=com", bound as=anonymous, schema=(schema not loaded)>
<?end?>

----
fn1. If there's one missing, let us know and we'll add it!
----

h2(#binding). Binding to the Directory

If you don't specify a user <abbr title="Distingished Name">DN</abbr> and password, a new @Directory@ object will be bound anonymously, which is usually sufficient for reading the public attributes of records, but it's likely that you'll need to bind as a particular user to write to the directory or access protected attributes:

<?example { language: irb, caption: "Binding to the directory." } ?>
irb> dir.bind( 'uid=mgranger,ou=people,dc=acme,dc=com', 'my_password' )
# => "uid=mgranger,ou=people,dc=acme,dc=com"
<?end?>

You can also bind to the directory by creating it using a URL that contains _authority_ information; this is not recommended for production use, as it requires that the password be in plain text in the connection information, but it's supported for convenience's sake:

<?example { language: irb, caption: "Fetching a directory by URL with automatic binding." } ?>
irb> url = 'ldap://cn=user,dc=acme,dc=com:my_password@localhost/dc=acme,dc=com'
irb> dir = Treequel.directory( url )
# => #<Treequel::Directory:0x4f052e localhost:389 (not connected) base="dc=acme,dc=com", bound as="cn=user,dc=acme,dc=com", schema=(schema not loaded)>
<?end?>

h3(#unbinding). Unbinding

You can also revert back to an anonymous binding by calling @#unbind@.

h3(#rebinding). Binding With A Block

If you want to rebind as a different user for just a few operations, you can do that by calling the @#bound_as@ method with a block that contains the operations which require more privileges:

<?example { language: irb, caption: "Executing a block with a different binding." } ?>
irb> dir.bound_as( 'cn=admin,dc=acme,dc=com', 's00per:sekrit' ) { dir }
# => #<Treequel::Directory:0x4f052e localhost:389 (not connected) base="dc=acme,dc=com", bound as="cn=admin,dc=acme,dc=com", schema=(schema not loaded)>
<?end?>

Once the block returns, the binding reverts to what it previously was.

There are a bunch of other things you can do with the Directory object, but in most cases you won't interact with it directly except as the root of the directory. To interact with the entries in the directory, you'll probably want to start with a <?api Treequel::Branch ?>.

h2(#branches). Branches

Once you've established a connection to a directory, you can fetch entries from the directory hierarchy by traversing the directory hierarchy using Branches. A Branch (<?api Treequel::Branch ?>) is just a wrapper around a DN. The wrapped DN doesn't necessarily need to map to an extant entry in the directory; the entry behind it isn't fetched until it's needed for something. 

You can get a Branch for a DN in several ways. The easiest, once you have a @Directory@, is to use the <abbr title="Relative Distinguished Name">RDN</abbr> from the base of the directory to fetch it. You can fetch a @Branch@ from a @Directory@ or any other @Branch@ by calling a method on it with the same name as one of the attributes of the @RDN@ you want to traverse, and passing the value as the first argument to that method.

For instance, my company's directory has people organized under a top-level <abbr title="Organizational Unit">OU</abbr> called "people", so I can fetch a @Branch@ for it like so:

<?example { language: irb, caption: "Fetching a branch ou=people." } ?>
irb> people = dir.ou( :people )
# => #<Treequel::Branch:0x19a76d4 ou=people,dc=acme,dc=com @ localhost:389 (dc=acme,dc=com, tls, anonymous) entry=nil>
irb> people.dn
# => "ou=people,dc=acme,dc=com"
<?end?>

Then you can fetch branches for individuals under @ou=People@ by calling their @RDN@ method, too. Since I happen to know that all of my company's People are keyed by @uid@, everyone's @RDN@ from @ou=People@ will be @uid=something@:

<?example { language: irb, caption: "Fetching a branch for uid=mgranger,ou=people." } ?>
irb> me = people.uid( :mgranger )
# => #<Treequel::Branch:0x19a4970 uid=mgranger,ou=people,dc=acme,dc=com @ localhost:389 (dc=acme,dc=com, tls, anonymous) entry=nil>
irb> me.dn
# => "uid=mgranger,ou=people,dc=acme,dc=com"
<?end?>

You can pass any additional attributes in the @RDN@ (if you have entries with multi-value @RDNs@) as a Hash:

<?example { language: irb, caption: "Fetching a branch for an entry with a multi-value RDN." } ?>
irb> hosts = dir.ou( :hosts )
# => #<Treequel::Branch:0x19a76d4 ou=hosts,dc=acme,dc=com @ localhost:389 (dc=acme,dc=com, tls, anonymous) entry=nil>
irb> hosts.cn( :ns1, :l => 'newyork' ).dn
# => "cn=ns1+l=newyork,ou=hosts,dc=acme,dc=com"
<?end?>

You can also create a Branch from the directory that contains it and its full DN:

<?example { language: irb, caption: "Fetching a branch using its DN." } ?>
irb> me = Treequel::Branch.new( dir, 'uid=mgranger,ou=people,dc=acme,dc=com' )
# => #<Treequel::Branch:0x12b676c uid=mgranger,ou=people,dc=acme,dc=com @ localhost:389 (dc=acme,dc=com, tls, anonymous) entry=nil>
<?end?>

or from a raw @LDAP::Entry@ object:

<?example { language: irb, caption: "Fetching a branch using its DN." } ?>
irb> conn = LDAP::SSLConn.new( 'localhost', 389, true )
# => #<LDAP::SSLConn:0x58bd94>
irb> entries = conn.search2( 'ou=people,dc=acme,dc=com', LDAP::LDAP_SCOPE_SUBTREE, '(uid=mgranger)' )
# => [{"gidNumber"=>["200"], "cn"=>["Michael Granger"], [...], "dn"=>["uid=mgranger,ou=People,dc=acme,dc=com"]}]
irb> me = Treequel::Branch.new_from_entry( entries.first, dir )
# => #<Treequel::Branch:0x129dd70 uid=mgranger,ou=People,dc=acme,dc=com @ localhost:389 (dc=acme,dc=com, tls, anonymous) entry={...}>
<?end?>

The directory also provides a special @Branch@ object for its base DN that's used to respond to any Branch methods called on it:

<?example { language: irb, caption: "Fetching the directory's base branch." } ?>
irb> dir.base
# => #<Treequel::Branch:0x1368548 dc=acme,dc=com @ localhost:389 (dc=acme,dc=com, tls, anonymous) entry=nil>
irb> dir.base.dn
# => "dc=acme,dc=com"
irb> dir.dn
# => "dc=acme,dc=com"
irb> dir.base.ou( :people )
# => #<Treequel::Branch:0x117f45c ou=people,dc=acme,dc=com @ localhost:389 (dc=acme,dc=com, tls, anonymous) entry=nil>
irb> dir.ou( :people )
# => #<Treequel::Branch:0x11850f0 ou=people,dc=acme,dc=com @ localhost:389 (dc=acme,dc=com, tls, anonymous) entry=nil>
<?end?>


Branches are also returned as the results from a search, but "that will be covered a little later":#searching-with-branchsets.

h3(#entries). The Branch's Entry

Once you have a Branch, you can fetch its corresponding entry from the directory via the @#entry@ method. If the entry doesn't exist, @#entry@ will return @nil@. You can test to see whether an entry for a branch exists via its @#exists?@ predicate method:

<?example { language: irb, caption: "Examining a Branch's entry." } ?>
irb> www = dir.ou( :hosts ).cn( :www )
# => #<Treequel::Branch:0x1932f8c cn=www,ou=hosts,dc=acme,dc=com @ localhost:389 (dc=acme,dc=com, tls, cn=admin,dc=acme,dc=com) entry=nil>
irb> www.exists?
# => true
irb> www.entry
# => {"cn"=>["www"], "ipHostNumber"=>["127.0.0.1"], "objectClass"=>["device", "ipHost"], "dn"=>["cn=www,ou=hosts,dc=acme,dc=com"]}
<?end?>

h3(#attributes). Attributes

Once you have a the Branch for the entry you need, you can also fetch its attributes just like a Hash:

<?example { language: irb, caption: "Fetching an attribute." } ?>
irb> me = people.uid( :mgranger )
irb> me[:gecos]
# => "Michael Granger"
<?end?>

If you have write privileges on the entry, you can set attributes the same way:

<?example { language: irb, caption: "Setting an attribute." } ?>
irb> dir.bound_as( me, 'password' ) { me[:gecos] = "Pasoquod Singular" }
irb> me[:gecos] 
# => "Pasoquod Singular"
<?end?>

Changes to the branch are written to the directory as soon as they're made, so if you have several attributes to change, you'll likely want to make them all at once for efficiency.

You can do that with the @#merge@ method:

<?example { language: irb, caption: "Merging attributes." } ?>
irb> me.merge( :gecos => 'Michael Granger', :uidNumber => 514 )
<?end?>

h3(#attribute-datatypes). Attribute Datatypes

Attribute values are cast to Ruby objects and vice-versa based on the "syntax rule":http://tools.ietf.org/html/rfc4517#section-3.3 that corresponds to its attribute type. By default, all attribute values from LDAP are mapped to <code>String</code>s except those contained in <var>Treequel::Directory::DEFAULT_ATTRIBUTE_CONVERSIONS</var>, which is a mapping of syntax rule <code>OID</code>s to an object which converts the @String@ value from the directory into a Ruby object. This object can be of any type which responds to @#call@, in which case it will be called with the attribute and the @Directory@ it belongs to, or to @#[]@ with a @String@ argument, e.g., a  @Hash@:

<?example { language: irb, caption: "Convert integer values to Ruby Integers" } ?>
irb> dir.add_attribute_conversion( Treequel::OIDS::INTEGER_SYNTAX ) {|string, _| Integer(string) }
# => #<Proc:0x00507080@(irb):3>
irb> dir.convert_to_object( Treequel::OIDS::INTEGER_SYNTAX, "181" )
# => 181
<?end ?>

This is, incidentally, how every attribute that's a <abbr title="Distingished Name">DN</abbr> gets returned as a @Treequel::Branch@ instead of the DN string. If you were doing this yourself (or wanted to override the conversion to return something else), you do:

<?example { language: irb, caption: "Mapping DNs to Treequel::Branches" } ?>
irb> dir = Treequel.directory 
# => #<Treequel::Directory:0x665783 localhost:389 (connected) base_dn="dc=acme,dc=com", bound as=anonymous, schema=(schema not loaded)>
irb> dir.add_attribute_conversion( Treequel::OIDS::DISTINGUISHED_NAME_SYNTAX ) {|dn, dir| Treequel::Branch.new(dir, dn) }
# => #<Proc:0x0198ddd8@(irb):2>
irb> sales_dept = dir.ou( :departments ).cn( :sales )
# => #<Treequel::Branch:0x18def54 cn=sales,ou=departments,dc=acme,dc=com @ localhost:389 (dc=acme,dc=com, tls, anonymous) entry=nil>
irb> sales_dept['supervisor']
# => #<Treequel::Branch:0x18db228 uid=mahlon,ou=People,dc=acme,dc=com @ localhost:389 (dc=acme,dc=com, tls, anonymous) entry=nil>
<?end?>

You could also do this by setting the @Directory.results_class@, but that'll come up later in the section about "Models":#treequel-model.

To map Ruby objects back into LDAP attribute strings, there's a corollary to the <var>DEFAULT_ATTRIBUTE_CONVERSIONS</var> called <var>DEFAULT_OBJECT_CONVERSIONS</var> that works the same way, but in reverse. The values registered with it are given the Ruby object and the @Directory@, and return the LDAP-encoded String:

<?example { language: irb, caption: "Convert objects to LDAP bit strings" } ?>
irb> dir.add_object_conversion( Treequel::OIDS::BIT_STRING_SYNTAX ) {|bs, _| bs.to_i.to_s(2) }
# => #<Proc:0x00000101840d80@(irb):3>
irb> dir.convert_to_attribute( Treequel::OIDS::BIT_STRING_SYNTAX, 169130 )
# => "101001010010101010"
<?end?>

<div class="callout note-callout">
Syntax mappings are per-directory, so you can establish different conversion rules for different directories. We're planning on adding a way to add or replace the default rules, too, but for now you'll have to either modify <var>Treequel::Directory::DEFAULT_ATTRIBUTE_CONVERSIONS</var> directly or
install custom mappings for each @Directory@ individually if you want the same rules for every one.
</div>

h3(#operational-attributes). Operational Attributes

In addition to its user-settable attributes, each entry in the directory also has a set of "operational attributes":http://tools.ietf.org/html/rfc4512#section-3.4 which are maintained by the server. These attributes are not normally visible, but you can enable them either for individual @Branch@ objects, or for all newly-created <code>Branch</code>es:

<?example { language: irb, caption: "Enabling the inclusion of operational attributes." } ?>
irb> dir.base.entry.keys.sort
# => ["dc", "description", "dn", "o", "objectClass"]
irb> dir.base.include_operational_attrs = true
# => true
irb> dir.base.entry.keys.sort
# => ["createTimestamp", "creatorsName", "dc", "description", "dn", "entryCSN", "entryDN", "entryUUID", "hasSubordinates", "modifiersName", "modifyTimestamp", "o", "objectClass", "structuralObjectClass", "subschemaSubentry"]
irb> Treequel::Branch.include_operational_attrs = true
# => true
irb> dir.ou( :people ).entry.keys.sort
# => ["createTimestamp", "creatorsName", "description", "dn", "entryCSN", "entryDN", "entryUUID", "hasSubordinates", "modifiersName", "modifyTimestamp", "objectClass", "ou", "structuralObjectClass", "subschemaSubentry"]
<?end?>

To see which operational attributes your directory software supports, ask the <code>Directory</code> object, which will return schema objects for each one:

<?example { language: irb, caption: "Get the list of supported operational attributes." } ?>
irb> dir.operational_attribute_types.map( &:name )
# => [:structuralObjectClass, :createTimestamp, :modifyTimestamp, :creatorsName, :modifiersName, :hasSubordinates, :subschemaSubentry, :entryDN, :entryUUID, :altServer, :namingContexts, :supportedControl, :supportedExtension, :supportedLDAPVersion, :supportedSASLMechanisms, :supportedFeatures, :vendorName, :vendorVersion, :matchingRules, :attributeTypes, :objectClasses, :matchingRuleUse, :ldapSyntaxes, :ref, :entryTtl, :dynamicSubtrees, :memberOf, :pwdChangedTime, :pwdAccountLockedTime, :pwdFailureTime, :pwdHistory, :pwdGraceUseTime, :pwdReset, :pwdPolicySubentry]
<?end?>


h3(#branch-ldif). Getting a Branch's LDIF

A convenient way to look at all of a branch's attributes is via its "LDIF":http://en.wikipedia.org/wiki/LDAP_Data_Interchange_Format string:

<?example { language: irb, caption: "Displaying a branch's entry as LDIF." } ?>
irb> puts me.to_ldif
dn: uid=mgranger,ou=people,dc=acme,dc=com
gidNumber: 200
cn: Michael Granger
l: Portland, OR
givenName: Michael
title: Lead Software Developer
gecos: Michael Granger
homeDirectory: /home/m/mgranger
uid: mgranger
mail: mgranger@acme.com
sn: Granger
mobile: +1 9075551212
loginShell: /bin/base
uidNumber: 2053
objectClass: inetOrgPerson
objectClass: organizationalPerson
objectClass: person
objectClass: top
objectClass: posixAccount
objectClass: shadowAccount
objectClass: apple-user
homePhone: +1 9075551212
departmentNumber: 18
<?end?>

h3(#heirarchical-traversal). Parents and Children

Each branch can also fetch its parent and its children:

<?example { language: irb, caption: "Fetching a branch's parent and its children." } ?>
irb> marketing_hosts = dir.dc( :marketing ).ou( :hosts )
# => #<Treequel::Branch:0x135ad94 ou=hosts,dc=marketing,dc=acme,dc=com @ localhost:389 (dc=acme,dc=com, tls, anonymous) entry=nil>
irb> marketing_hosts.parent
# => #<Treequel::Branch:0x13508d0 dc=marketing,dc=acme,dc=com @ localhost:389 (dc=acme,dc=com, tls, anonymous) entry=nil>
irb> marketing_hosts.children.map {|b| b.dn }
# => ["cn=rockbox,ou=Hosts,dc=marketing,dc=acme,dc=com", "cn=bone,ou=Hosts,dc=marketing,dc=acme,dc=com"]
<?end?>

h3(#create-copy-delete-move). Creating, Copying, Deleting, and Moving Entries

If you have a @Branch@ object for an entry which doesn't exist in the directory, you can create it via the @#create@ method. It takes any attributes that should be set when creating it, and requires at least that you provide a "structural objectClass":http://tools.ietf.org/html/rfc4512#page-18.

<?example { language: irb, caption: "Creating a new entry." } ?>
irb> mahlon_things = dir.ou( :people ).uid( :mahlon ).ou( :things )
# => #<Treequel::Branch:0xfb7b9e954 ou=things,uid=mahlon,ou=people,dc=acme,dc=com @ localhost:389 (dc=acme,dc=com, tls, anonymous) entry=nil>
irb> mahlon_things.create( :objectClass => [ 'top', 'organizationalUnit' ] )
# => true
irb> mahlon_things.cn( :thing ).create( :objectClass => 'room', :description => 'a thing' )
# => true
<?end?>

Some objectClasses require that the entry contain values for particular attributes (their @MUST@ attributes), and it's nice to be able to tell which ones you'll need if you're building tools that can create new entries. To that end, Treequel comes with a set of tools for fetching and using the information contained in a Directory's schema. We'll cover schema introspection "a little later":#schema-introspection.

You can also copy an existing entry:

<?example { language: irb, caption: "Copying an entry." } ?>
irb> dir.bind( 'cn=admin,dc=acme,dc=com', 'the_password' )
# => "cn=admin,dc=acme,dc=com"
irb> jtran = dir.ou( :people ).uid( :mahlon ).copy( 'uid=jtran', :givenName => 'Jim', :sn => 'Tran' )
# => #<Treequel::Branch:0x12bff60 uid=jtran,ou=people,dc=acme,dc=com @ localhost:389 (dc=acme,dc=com, tls, cn=admin,dc=acme,dc=com) entry=nil>
irb> jtran['sn']
# => ["Tran"]
<?end?>

or move (rename) it:

<?example { language: irb, caption: "Moving an entry." } ?>
# Rename 'Miriam Robson' to 'Miriam Price' when she gets married.
irb> user = dir.ou( :people ).uid( :mrobson ).move( 'uid=mprice', :sn => 'Price' )
# => #<Treequel::Branch:0x12bff60 uid=mprice,ou=people,dc=acme,dc=com @ localhost:389 (dc=acme,dc=com, tls, cn=admin,dc=acme,dc=com) entry=nil>
<?end?>

<?ed fixme:"Treequel currently doesn't support moving an entry to a new parent, only renaming it under its current parent, but you can always copy it to the new DN and delete the original. This will be corrected in a future version." ?>

Finally, you can delete an entry from its @Branch@, as well:

<?example { language: irb, caption: "Deleting an entry." } ?>
irb> dir.ou( :hosts ).cn( :ns1 ).delete
# => true
<?end?>

h2(#searching-with-branchsets). Searching With Branchsets

If you know exactly which entries you need, it's pretty easy to fetch the corresponding @Branch@ objects, but what if you need to search for entries matching one or more criteria?

Searching is implemented in Treequel via <?api "Treequel::Branchsets":Treequel::Branchset ?>. Much like "Datasets":http://sequel.rubyforge.org/rdoc/classes/Sequel/Dataset.html from the "Sequel library":http://sequel.rubyforge.org/ which inspired Treequel, a @Branchset@ is an object which represents an abstract set of records returned by a search. The results of the search are returned on demand, so a @Branchset@ can be kept around and reused indefinitely.

You can construct a new @Branchset@ via the usual constructor; it takes the @Branch@ for the base DN of the search:

<?example { language: irb, caption: "Creating a new Branchset." } ?>
irb> Treequel::Branchset.new( dir.ou(:people) )
# => #<Treequel::Branchset:0x1a418ec base_dn='ou=people,dc=acme,dc=com', filter=(objectClass=*), scope=subtree, select=*, limit=0, timeout=0.000>
<?end?>

There are also several convenience methods on @Branch@ and @Directory@ that can create a new @Branchset@ relative to themselves, as well:

<?example { language: irb, caption: "Creating new Branchsets relative to the base DN and ou=Hosts." } ?>
irb> dir.branchset
# => #<Treequel::Branchset:0x1a3fc54 base_dn='dc=acme,dc=com', filter=(objectClass=*), scope=subtree, select=*, limit=0, timeout=0.000>
irb> dir.ou(:people).branchset
# => #<Treequel::Branchset:0x1998314 base_dn='ou=people,dc=acme,dc=com', filter=(objectClass=*), scope=subtree, select=*, limit=0, timeout=0.000>
<?end?>

Like _Sequel_ Datasets, Branchsets are meant to be chainable, so you can refine what entries it will find by calling one of its mutators. Each mutator method returns a new @Branchset@ with the new criteria set. This allows you to build up a query for what you need gradually, in a concise and flexible manner.

h3(#branchset-filter). Filter

The first of these mutators is @#filter@.

You can narrow the results of that search by adding one or more filter statements. Each call to @#filter@ adds a clause to the LDAP filter string that is eventually sent to the server.

With no modifications, a @Branchset@ will find every entry below its base using a filter of @(objectClass=*)@ (which will match every entry). 

The @#filter@ method expects one or more expressions which are transformed into an "LDAP filter":http://tools.ietf.org/html/rfc4515, and can be a literal filter String, a Hash or an Array of criteria, or a Ruby expression.

The simplest of these, of course, is a literal LDAP filter in a @String@:

<?example { language: irb, caption: "Literal string filter expression" } ?>
irb> dir.ou( :people ).filter( '(objectClass=room)' )
=> #<Treequel::Branchset:0x12b7c48 base_dn='ou=people,dc=acme,dc=com', filter=(objectClass=room), scope=subtree, select=*, limit=0, timeout=0.000>
<?end?>

You can see what the equivalent filter of a @Branchset@ is at any time using its @#filter_string@ method:

<?example { language: irb, caption: "Literal string filter expression" } ?>
irb> dir.ou( :people ).filter( '(objectClass=room)' ).filter_string
# => "(objectClass=room)"
<?end?>

You can also use a @Hash@ to do simple @attribute=value@ matching:

<?example { language: irb, caption: "Hash filter expression" } ?>
irb> dir.ou( :people ).filter( :givenName => 'Michael' ).filter_string
# => "(givenName=Michael)"
<?end?>

Multiple criteria in a Hash will be ANDed together:

<?example { language: irb, caption: "Multi-value Hash filter expression" } ?>
irb> dir.ou( :people ).filter( :givenName => 'Michael', :sn => 'Granger' )
# => "(&(givenName=Michael)(sn=Granger))"
<?end?>

You can include an OR in a filter by passing @:or@ as the first element:

<?example { language: irb, caption: "An ORed filter" } ?>
irb> dir.ou( :people ).filter( :or, [:sn, 'Granger'], [:sn, 'Smith'] ).filter_string
# => "(|(sn=Granger)(sn=Smith))"
<?end?>

or by specifying more than one value for a single attribute:

<?example { language: irb, caption: "ORing with a Hash" } ?>
# => #<Treequel::Directory:0x4e45d5 localhost:389 (connected) base_dn="dc=acme,dc=com", bound as=anonymous, schema=(schema not loaded)>
irb> dir.ou( :people ).filter( :uid => [:mahlon, :mgranger, :jtran] ).filter_string
<?end?>

You can do the same with @:and@ and @:not@, and combine them, too:

<?example { language: irb, caption: "Negation (NOT) of an explicit AND" } ?>
irb> dir.ou( :people ).filter( :and, [:sn, 'Granger'], [:sn, 'Smith'] ).filter_string
# => "(&(sn=Granger)(sn=Smith))"
irb> dir.ou( :people ).filter( :not, [:and, [:sn, 'Granger'], [:sn, 'Smith']] ).filter_string
# => "(!(&(sn=Granger)(sn=Smith)))"
<?end?>

Because @filter@ returns the mutated branchset, you can always chain them together instead of using an explicit @:and@.

<?example { language: irb, caption: "Chaining filter expressions ANDs them, too." } ?>
irb> dir.ou( :people ).filter( :objectClass => 'inetOrgPerson' ).filter( :sn => 'Smith' ).filter_string
# => "(&(objectClass=inetOrgPerson)(sn=Smith))"
<?end?>

We're experimenting with support for Sequel expressions for more-complex filter expressions, too:

<?example { language: irb, caption: "Advanced expressions" } ?>
# Negative 
irb> dir.ou( :people ).filter( ~:photo ).filter_string
# => "(!(photo=*))"
irb> dir.ou( :people ).filter( :employeeNumber <= 1000 ).filter_string
# => "(employeeNumber<=1000)"
irb> dir.ou( :people ).filter( :sn.like('smith') ).filter_string
# => "(sn~=smith)"
irb> dir.ou( :people ).filter( :sn.like('sm*') ).filter_string
# => "(sn=sm*)"
irb> dir.ou( :people ).filter( :sn => ['smith', 'tran'] ).filter_string
# => "(|(sn=smith)(sn=tran))"
<?end?>


h3(#branchset-scope). Scope

You can also create a @Branchset@ that will search using a different scope by passing @:onelevel@, @:base@, or @:subtree@ (the default) to the @#scope@ method of the original @Branchset@:

Setting the scope to @:onelevel@ (as you might expect) means that it will only descend one level when searching:

<?example { language: irb, caption: "Find all the top-level OUs" } ?>
irb> dir.filter( :objectClass => :organizationalUnit ).scope( :one ).collect {|branch| branch[:ou].first }
=> ["Hosts", "Groups", "Lists", "Resources", "People", "Departments", "Netgroups"]
<?end?>

Setting it to @:subtree@ (which is the default) means that it will descend infinitely, and setting it to @:base@ means that it will only consider the base entry, either returning it if it matches, or returning @nil@ if it does not.

h3(#branchset-limit). Limit

Setting a Branchset's @#limit@ will limit the number of results the search will return.

<?example { language: irb, caption: "Return the first 5 groups in the directory" } ?>
irb> dir.ou( :groups ).limit( 5 ).collect {|b| b.dn }
# => ["ou=Groups,dc=acme,dc=com", "cn=anim,ou=Groups,dc=acme,dc=com", "cn=acct,ou=Groups,dc=acme,dc=com", "cn=mailuser,ou=Groups,dc=acme,dc=com", "cn=producer,ou=Groups,dc=acme,dc=com"]
<?end?>

<div class="callout caution-callout">
*Note* that the results will be returned in _directory order_ (at least in OpenLDAP). Until Treequel supports "server-side ordering":http://tools.ietf.org/html/rfc2891, this means that @#limit@ is of limited usefulness; to do real paged results you need both server-side ordering and "the paged results control":http://tools.ietf.org/html/rfc2696.

We're planning on adding a convenient way to use "controls":http://tools.ietf.org/html/rfc4511#page-14 in a future release.
</div>

If you already have a @Branchset@ with a limit, and want a new one that won't have any limits imposed on it, you can get one via the @#without_limit@ method.

<?example { language: irb, caption: "Making a Branchset without the limits of the original" } ?>
irb> fivegroups = dir.ou( :groups ).limit( 5 )
# => #<Treequel::Branchset:0x1264908 base_dn='ou=groups,dc=acme,dc=com', filter=(objectClass=*), scope=subtree, select=*, limit=5, timeout=0.000>
irb> fivegroups.all.length
# => 5
irb> fivegroups.without_limit.all.length
# => 99
<?end?>

h3(#branchset-select). Select

If you should want to limit the attributes that are returned in the entries fetched by the query, you can do so by specifying which ones should be returned with the @#select@ method:

<?example { language: irb, caption: "Fetch only employee first and last names" } ?>
irb> dir.ou( :people ).select( :sn, :givenName ).limit( 5 ).collect {|b| b.entry }
# => [{"dn"=>["ou=People,dc=acme,dc=com"]}, {"givenName"=>["Reed"], "sn"=>["Slimlocke"], "dn"=>["uid=rslim,ou=People,dc=acme,dc=com"]}, {"givenName"=>["Jim"], "sn"=>["Tran"], "dn"=>["uid=jtran,ou=People,dc=acme,dc=com"]}, {"givenName"=>["Michael"], "sn"=>["Granger"], "dn"=>["uid=mgranger,ou=People,dc=acme,dc=com"]}, {"givenName"=>["Harken"], "sn"=>["Farkselstein"], "dn"=>["uid=hfarkselstein,ou=People,dc=acme,dc=com"]}]
<?end?>

You can get a copy of a Branchset with additional attributes by passing the additional attributes to @#select_more@:

<?example { language: irb, caption: "Selecting additional attributes" } ?>
irb> people_uids = dir.ou( :people ).select( :uid )
# => #<Treequel::Branchset:0x1181644 base_dn='ou=people,dc=acme,dc=com', filter=(objectClass=*), scope=subtree, select=uid, limit=0, timeout=0.000>
irb> people_uids_and_names = people_uids.select_more( :gecos )
# => #<Treequel::Branchset:0x1178b20 base_dn='ou=people,dc=acme,dc=com', filter=(objectClass=*), scope=subtree, select=uid,gecos, limit=0, timeout=0.000>
irb> people_uids_names_and_addresses = people_uids.select_more( :gecos, :homePostalAddress )
# => #<Treequel::Branchset:0x10dcb08 base_dn='ou=people,dc=acme,dc=com', filter=(objectClass=*), scope=subtree, select=uid,gecos,homePostalAddress, limit=0, timeout=0.000>
<?end?>

You can also get a copy with the select-list removed:

<?example { language: irb, caption: "Removing the selection from a branchset" } ?>
irb> people_uids.select_all
# => #<Treequel::Branchset:0x10da308 base_dn='ou=people,dc=acme,dc=com', filter=(objectClass=*), scope=subtree, select=*, limit=0, timeout=0.000>
<?end ?>

h3(#branchset-timeout). Timeout

To avoid unintentional resource consumption on the server, you can specify an explicit timeout for queries.  This is useful when searching with user submitted input or other untrusted sources.  Note that this can only be reliably used to _decrease_ the timeout, as the server might have a maximum timeout configured that can't be exceeded.

<?example { language: irb, caption: "A long running query" } ?>
irb> dir.filter('objectClass=*').timeout( 1 ).all
LDAP::ResultError: Timed out
	from ./treequel/directory.rb:328:in `search_ext2'
	from ./treequel/directory.rb:328:in `search'
	from ./treequel/branchset.rb:195:in `each'
	from (irb):8:in `all'
	from (irb):8
	from :0
<?end?>

If you have a canned query that includes a timeout, you can copy it without the restriction.

<?example { language: irb, caption: "A long running query with timeout disabled" } ?>
irb> slow_query = dir.filter('objectClass=*').timeout( 1 )
# => #<Treequel::Branchset:0x1d5c554 base_dn='dc=acme,dc=com', filter=(objectClass=*), scope=subtree, select=*, limit=0, timeout=1.000>
irb> slow_query.all
LDAP::ResultError: Timed out
	from ./treequel/directory.rb:328:in `search_ext2'
	from ./treequel/directory.rb:328:in `search'
	from ./treequel/branchset.rb:195:in `each'
	from (irb):13:in `all'
	from (irb):13
	from :0
irb> slow_query.without_timeout.all.length
# => 4982
irb> slow_query.without_timeout.all.first
# => #<Treequel::Branch:0x1d4f2f0 dc=acme,dc=com @ localhost:389 (dc=acme,dc=com, tls, anonymous) entry={"o"=>["ACME"], "description"=>["http://www.example.com/"], "objectClass"=>["dcObject", "organization"], "dc"=>["acme"], "dn"=>["dc=acme,dc=com"]}>
<?end?>


h3. Branchset Enumeration

Branchsets are also @Enumerable@, so you can slice and dice results with its interface:

<?example { language: irb, caption: "Enumerating resulting Branches" } ?>
irb> people = dir.ou( :people )
# => #<Treequel::Branch:0x11857d0 ou=people,dc=acme,dc=com @ localhost:389 (dc=acme,dc=com, tls, anonymous) entry=nil>
irb> people.all? {|person| File.directory?(person[:homeDirectory]) }
NoMethodError: undefined method `all?' for #<Treequel::Branch:0x11857d0>
	from /Users/mgranger/source/ruby/Treequel/lib/treequel/branch.rb:538:in `method_missing'
	from (irb):3
irb> people.filter( :homeDirectory ).all? {|person| File.directory?(person[:homeDirectory]) }
# => false
irb> people.filter( :homeDirectory ).find_all {|person| File.exist?(person[:homeDirectory]) && File.stat(person[:homeDirectory]).uid != person[:uidNumber] }
# => [#<Treequel::Branch:0x18287b8 uid=wwwspider,ou=People,dc=acme,dc=com @ localhost:389 (dc=acme,dc=com, tls, anonymous) entry={"cn"=>["Auth account for web spider"], "gidNumber"=>["200"], "givenName"=>["WebSpider"], "gecos"=>["WebSpider Account"], "homeDirectory"=>["/dev/null"], "sn"=>["WebSpider Account"], "uid"=>["wwwspider"], "uidNumber"=>["1500"], "objectClass"=>["top", "person", "inetOrgPerson", "posixAccount", "shadowAccount"], "dn"=>["uid=wwwspider,ou=People,dc=acme,dc=com"]}>]
<?end ?>

For convenience, the @Branchset#map@ method is overriden to facilitate fetching single attributes from the resulting branches:

<?example { language: irb, caption: "Mapping branch attributes" } ?>
irb> dir.ou( :hosts ).filter( :ipHostNumber ).map( :ipHostNumber ).flatten
=> ["192.168.1.253", "192.168.1.14", "192.168.1.21", "192.168.1.22", "192.168.1.23"]
<?end?>


h2. Branch Collections

So far we've been searching from a single base DN, but sometimes what you want is located in different branches of the directory.

For example, hosts might be listed under different domainComponents under the base that correspond to subdomains:

<?example { language: irb, caption: "" } ?>
irb> dir.filter( :objectClass => 'dcObject' ).scope( :one ).map( :dc )
# => ["sales", "marketing", "admin", "it", "vpn"]
<?end ?>

<?api Treequel::BranchCollection ?>s can be used to form searches from multiple bases. They can be constructed from one or more Branchsets:

<?example { language: irb, caption: "Creating a collection from explicit Branchsets" } ?>
irb> collection = Treequel::BranchCollection.new( dir.dc(:marketing).branchset, dir.dc(:sales).branchset )
# => #<Treequel::BranchCollection:0x10ef8c0 2 branchsets: ["dc=marketing,dc=acme,dc=com/(objectClass=*)", "dc=sales,dc=acme,dc=com/(objectClass=*)"]>
<?end?>

or directly from Branches, which will be converted to Branchsets:

<?example { language: irb, caption: "Creating BranchCollection based on the results of a search" } ?>
irb> collection = Treequel::BranchCollection.new( dir.dc(:marketing), dir.dc(:sales) )
# => #<Treequel::BranchCollection:0x10c2dfc 2 branchsets: ["dc=marketing,dc=acme,dc=com/(objectClass=*)", "dc=sales,dc=acme,dc=com/(objectClass=*)"]>
<?end ?>

or via @Treequel::Branchset@'s @#collection@ method:

<?example { language: irb, caption: "A more-convenient way to turn the results returned by a Branchset into a collection." } ?>
irb> collection = dir.scope(:one).filter(:objectClass => 'dcObject', :dc => ['sales', 'marketing']).collection
# => #<Treequel::BranchCollection:0x50b644 2 branchsets: ["dc=marketing,dc=acme,dc=com/(objectClass=*)", "dc=sales,dc=acme,dc=com/(objectClass=*)"]>
<?end ?>

You can also compose BranchCollections by appending new Branchsets:

<?example { language: irb, caption: "Building up a BranchCollection gradually" } ?>
irb> coll = Treequel::BranchCollection.new
# => #<Treequel::BranchCollection:0x1021420 0 branchsets: []>
irb> coll << dir.dc( :sales )
# => #<Treequel::BranchCollection:0x1021420 1 branchsets: ["dc=sales,dc=acme,dc=com/(objectClass=*)"]>
irb> coll << dir.dc( :marketing )
# => #<Treequel::BranchCollection:0x1021420 2 branchsets: ["dc=sales,dc=acme,dc=com/(objectClass=*)", "dc=marketing,dc=acme,dc=com/(objectClass=*)"]>
<?end ?>

or by adding one BranchCollection to another:

<?example { language: irb, caption: "Combining two BranchCollections into one" } ?>
irb> east_coast = dir.filter( :dc => [:admin, :it] ).collection
# => #<Treequel::BranchCollection:0x594aac 2 branchsets: ["dc=it,dc=acme,dc=com/(objectClass=*)", "dc=admin,dc=acme,dc=com/(objectClass=*)"]>
irb> west_coast = dir.filter( :dc => [:sales, :marketing] ).collection
# => #<Treequel::BranchCollection:0x55d980 2 branchsets: ["dc=marketing,dc=acme,dc=com/(objectClass=*)", "dc=sales,dc=acme,dc=com/(objectClass=*)"]>
irb> national = east_coast + west_coast
# => #<Treequel::BranchCollection:0x554ec0 4 branchsets: ["dc=it,dc=acme,dc=com/(objectClass=*)", "dc=admin,dc=acme,dc=com/(objectClass=*)", "dc=marketing,dc=acme,dc=com/(objectClass=*)", "dc=sales,dc=acme,dc=com/(objectClass=*)"]>
<?end ?>

BranchCollections work via delegation to their Branchsets, so all of the mutator methods on Branchset are supported by BranchCollection. This means that you can chain collections and filters together, with collections serving as the base for further finer-grained searches:

<?example { language: irb, caption: "Find all hosts named 'www' under all @ou=hosts@ branches" } ?>
dir.filter( :ou => 'hosts' ).collection.filter( :cn => 'www' )
<?end ?>


h2(#models). Models

A common pattern when you're using any kind of datastore is to represent the data contained within it as a "domain model":http://www.martinfowler.com/eaaCatalog/domainModel.html. For relational databases, Martin Fowler's "Active Record" pattern has become the _de facto_ standard, and because of its popularity, a few people have tried to apply the same pattern to LDAP. However, LDAP records aren't of fixed dimensionality, and don't need to be grouped together in the directory, so applying the logic of relational sets only works for the simplest cases.

Treequel comes with its own set of tools for constructing domain models, tools that take advantage of Ruby's flexible object model to reflect the flexibility and organic nature of LDAP data.

h3(#modeling-objectclass). Modeling ObjectClasses

The principle component is a class called <?api Treequel::Model ?>, which provides the usual attribute accessors for the entry that it wraps, as well as a mechanism for layering functionality onto an object based on what its @objectClass@ attributes are.

The layers are mixin Modules that extend <?api Treequel::Model::ObjectClass ?>, each of which is associated with a particular combination of objectClasses and bases. Here's a fairly simple example that adds a method that expands any _labeledUri_ attributes of entries under @ou=people,dc=acme,dc=com@ that have the @inetOrgPerson@ objectClass:

<?example { language: ruby, caption: "Add url-expansion to @inetOrgPerson@ entries." } ?>
require 'treequel/model'
require 'treequel/model/objectclass'

module ACME::InetOrgPerson
	extend Treequel::Model::ObjectClass

	model_class Treequel::Model
	model_bases 'ou=people,dc=acme,dc=com'
	model_objectclasses :inetOrgPerson


	### Return the person's URIs as values in a Hash keyed by either the
	### associated label (if there is one), or a number if there's no
	### label.
	def labeled_uris
		counter = 0
		return self.labeled_uri.inject({}) do |hash, luri|
			uri, label = luri.split( /\s+/, 2 )
			unless label
				label = counter
				counter += 1
			end
			hash[ label ] = URI( uri )
			hash
		end
	end

end # module ACME::InetOrgPerson

<?end?>

The module first extends Treequel::Model::ObjectClass [line 5], and then registers itself with a model class [line 7]. The next two lines set which objectClasses and base DNs the mixin will apply to [lines 8 and 9], and then the code that follows declares the method that's added to applicable model objects.

For example, if the above code was in a file called @acme/inetorgperson.rb@:

<?example { language: irb, caption: "Get the labeledUris associated with the 'jonh' user." } ?>
require 'treequel/model'
require 'acme/inetorgperson'

directory = Treequel.directory_from_config
jonh = Treequel::Model.search( directory ).
	filter( :uid => 'jonh', :objectClass => :inetOrgPerson ).first
jonh.labeled_uris
# => {"My Homepage"=>#<URI::HTTP:0x00000102841f68 URL:http://example.com/>} 
<?end?>

h3(#model-associations). Model Associations

You can use the methods of the mixins to associate entries with one another, as well. For attributes that contain a full DN, fetching the value will automatically return another <?api Treequel::Model ?> instance, but for less-restrictive attributes like @memberUid@ that are just plain strings, you'll need to map them into the corresponding entry yourself:

<?example { language: ruby, caption: "Associate posixGroup memberUids with posixAccount uids." } ?>
require 'treequel/model'
require 'treequel/model/objectclass'

$directory = Treequel.directory_from_config

module ACME::PosixAccount
	extend Treequel::Model::ObjectClass

	model_class Treequel::Model
	model_bases 'ou=people,dc=acme,dc=com'
	model_objectclasses :posixAccount

	### Return ACME::PosixGroup objects for the groups the account is a member of.
	def groups
		return ACME::PosixGroup.search( $directory ).filter( :memberUid => self.uid ).all
	end

end # module ACME::PosixAccount


module ACME::PosixGroup
	extend Treequel::Model::ObjectClass

	model_class Treequel::Model
	model_bases 'ou=groups,dc=acme,dc=com'
	model_objectclasses :posixGroup

	### Return ACME::PosixAccount objects for the group's members
	def members
		return ACME::PosixAccount.search( $directory ).filter( :uid => self.memberUid ).all
	end

end # module ACME::PosixGroup
<?end?>

If you want to make the associations a bit more useful, you can return a <?api Treequel::Branchset ?> from the association methods instead of calling @.all@ on it immediately, which will allow the results to be filtered further by chaining additional filter methods:

<?example { language: ruby, caption: "Find all sysadmin accounts that don't have a password." } ?>
require 'treequel/model'
require 'treequel/model/objectclass'

$directory = Treequel.directory_from_config

# Re-open to modify the association to return a Branchset instead
module ACME::PosixGroup
	def members
		return ACME::PosixAccount.search( $directory ).filter( :uid => self.memberUid )
	end
end # module ACME::PosixGroup

sysadmin_group = ACME::PosixGroup.search( $directory ).
	filter( :cn => 'sysadmin' ).first
sysadmin_group.members.filter( ~:userPassword ).all

# => [#<Treequel::Model:0x100b0a2d8 uid=mahlon,ou=People,dc=acme,dc=com @ localhost:389 (dc=acme,dc=com, tls, anonymous) entry=nil>]
<?end ?>

Mahlon appears to be violating ACME Company policy [line 17]. He will be flogged in accordance with company handbook section C, paragraph 2.

If the functionality you wish to define requires attributes of two or more different _objectClasses_ , you can put all of them in the @model_objectclasses@ statement, and then the mixin will only apply to entries that have *all* of them. The @model_bases@ attribute can also take multiple values; entries will be limited to children of *any* of them.

h2(#schema-introspection). Schema Introspection

The information about the structure of the directory comes from its schema, and Treequel provides instrospection tools for accessing it in an object-oriented manner. You can get the <?api Treequel::Schema ?> from the directory by calling its @#schema@ method:

<?example { language: irb, caption: "Fetching the schema for a Directory." } ?>
irb> dir.schema
# => #<Treequel::Schema:0x66511b 1119 attribute types, 31 ldap syntaxes, 54 matching rule uses, 72 matching rules, 310 object classes>
<?end?>


h3(#schema-objectclasses). Object Classes

You can fetch information about the "objectClasses":http://tools.ietf.org/html/rfc4512#section-2.4 the directory knows about through the schema's @#object_classes@ Hash:

<?example { language: irb, caption: "Fetching  an ObjectClass object for the 'inetOrgPerson' objectClass." } ?>
irb> dir.schema.object_classes[:inetOrgPerson] 
# => #<Treequel::Schema::StructuralObjectClass:0x65d91b inetOrgPerson(2.16.840.1.113730.3.2.2) < "organizationalPerson" "RFC2798: Internet Organizational Person" MUST: [], MAY: [:audio, :businessCategory, :carLicense, :departmentNumber, :displayName, :employeeNumber, :employeeType, :givenName, :homePhone, :homePostalAddress, :initials, :jpegPhoto, :labeledURI, :mail, :manager, :mobile, :o, :pager, :photo, :roomNumber, :secretary, :uid, :userCertificate, :x500uniqueIdentifier, :preferredLanguage, :userSMIMECertificate, :userPKCS12]>
<?end?>

This hash is keyed by both OID and any associated names (as Symbols), and the value is a <?api Treequel::Schema::ObjectClass ?> object that contains the information about that objectClass parsed from the schema.

<?example { language: irb, caption: "Introspection on the inetOrgPerson objectClass." } ?>
irb> inetOrgPerson = dir.schema.object_classes[:inetOrgPerson] 
# => #<Treequel::Schema::StructuralObjectClass ...>
irb> inetOrgPerson.oid
# => "2.16.840.1.113730.3.2.2"
irb> inetOrgPerson.names
# => [:inetOrgPerson]
irb> inetOrgPerson.may_oids
# => [:audio, :businessCategory, :carLicense, :departmentNumber, :displayName, :employeeNumber, :employeeType, :givenName, :homePhone, :homePostalAddress, :initials, :jpegPhoto, :labeledURI, :mail, :manager, :mobile, :o, :pager, :photo, :roomNumber, :secretary, :uid, :userCertificate, :x500uniqueIdentifier, :preferredLanguage, :userSMIMECertificate, :userPKCS12]
irb> inetOrgPerson.desc
# => "RFC2798: Internet Organizational Person"
irb> inetOrgPerson.sup
# => #<Treequel::Schema::StructuralObjectClass:0x65fe6e person(2.5.6.6) < #<Treequel::Schema::AbstractObjectClass:0x6637ad top(2.5.6.0) < nil "top of the superclass chain" MUST: [:objectClass], MAY: []> "RFC2256: a person" MUST: [:sn, :cn], MAY: [:userPassword, :telephoneNumber, :seeAlso, :description]>
<?end?>

Treequel::Branch objects provide a shortcut for looking up the @Treequel::ObjectClass@ objects that correspond to its @objectClass@ properties:

<?example { language: irb, caption: "Fetching the objectClasses for an entry through its Branch." } ?>
irb> dir.base.object_classes
# => [#<Treequel::Schema::AuxiliaryObjectClass:0x68b168 dcObject(1.3.6.1.4.1.1466.344) < #<Treequel::Schema::AbstractObjectClass:0x690555 top(2.5.6.0) < nil "top of the superclass chain" MUST: [:objectClass], MAY: []> "RFC2247: domain component object" MUST: [:dc], MAY: []>, #<Treequel::Schema::StructuralObjectClass:0x68d02b organization(2.5.6.4) < #<Treequel::Schema::AbstractObjectClass:0x690555 top(2.5.6.0) < nil "top of the superclass chain" MUST: [:objectClass], MAY: []> "RFC2256: an organization" MUST: [:o], MAY: [:userPassword, :searchGuide, :seeAlso, :businessCategory, :x121Address, :registeredAddress, :destinationIndicator, :preferredDeliveryMethod, :telexNumber, :teletexTerminalIdentifier, :telephoneNumber, :internationaliSDNNumber, :facsimileTelephoneNumber, :street, :postOfficeBox, :postalCode, :postalAddress, :physicalDeliveryOfficeName, :st, :l, :description]>]
<?end?>

h3(#schema-attributetypes). Attribute Types

You can also fetch introspection information on entry "attributeTypes":http://tools.ietf.org/html/rfc4512#section-2.5.1 via the schema's @#attribute_types@ Hash:

<?example { language: irb, caption: "Fetching an AttributeType object for the 'surname' attribute." } ?>
irb> dir.schema.attribute_types[:surname]
# => #<Treequel::Schema::AttributeType:0x146abd sn(2.5.4.4) "RFC2256: last (family) name(s) for which the entity is known by" SYNTAX: nil (length: unlimited)>
<?end?>

Like with objectClasses, they are keyed both by numeric OID strings and their associated names (as Symbols), and the values are instances of <?api Treequel::Schema::AttributeType ?>.

<?example { language: irb, caption: "Fetching an AttributeType object for the 'inetOrgPerson' objectClass." } ?>
irb> sn = dir.schema.attribute_types[:surname]
# => #<Treequel::Schema::AttributeType:0x696ec8 sn(2.5.4.4) "RFC2256: last (family) name(s) for which the entity is known by" SYNTAX: nil (length: unlimited)>
irb> sn.oid
# => "2.5.4.4"
irb> sn.names
# => [:sn, :surname]
irb> sn.desc
# => "RFC2256: last (family) name(s) for which the entity is known by"
irb> sn.obsolete?
# => false
irb> sn.sup
sn.sup_oid   sn.sup_oid=  sn.sup       
irb> sn.sup
# => #<Treequel::Schema::AttributeType:0x69e542 name(2.5.4.41) "RFC4519: common supertype of name attributes" SYNTAX: "1.3.6.1.4.1.1466.115.121.1.15" (length: 32768)>
irb> sn.eq
sn.eql?                    sn.eqmatch_oid=            sn.equal?                  sn.equality_matching_rule  
sn.eqmatch_oid             
irb> sn.equal
sn.equal?                  sn.equality_matching_rule  
irb> sn.equality_matching_rule
# => #<Treequel::Schema::MatchingRule:0x687f7c caseIgnoreMatch(2.5.13.2)  SYNTAX: #<Treequel::Schema::LDAPSyntax:0x689043 1.3.6.1.4.1.1466.115.121.1.15(Directory String)>>
irb> sn.substr_matching_rule
# => #<Treequel::Schema::MatchingRule:0x688026 caseIgnoreSubstringsMatch(2.5.13.4)  SYNTAX: nil>
irb> sn.user_modifiable?
# => true
<?end?>

Branches also know how to fetch the attribute types that are allowed by their objectClasses' _MUST_ and _MAY_ OIDs:

<?example { language: irb, caption: "Fetching an AttributeType object for the 'inetOrgPerson' objectClass." } ?>
irb> base = dir.base
# => #<Treequel::Branch:0x1a7f8cc dc=acme,dc=com @ localhost:389 (dc=acme,dc=com, tls, anonymous) entry=nil>
irb> base.may_oids
# => [:userPassword, :searchGuide, :seeAlso, :businessCategory, :x121Address, :registeredAddress, :destinationIndicator, :preferredDeliveryMethod, :telexNumber, :teletexTerminalIdentifier, :telephoneNumber, :internationaliSDNNumber, :facsimileTelephoneNumber, :street, :postOfficeBox, :postalCode, :postalAddress, :physicalDeliveryOfficeName, :st, :l, :description]
irb> base.may_attribute_types
# => [#<Treequel::Schema::AttributeType:0x69e1af userPassword(2.5.4.35) "RFC4519/2307: password of user" SYNTAX: "1.3.6.1.4.1.1466.115.121.1.40" (length: 128)>, #<Treequel::Schema::AttributeType:0x6968ce searchGuide(2.5.4.14) "RFC2256: search guide, deprecated by enhancedSearchGuide" SYNTAX: "1.3.6.1.4.1.1466.115.121.1.25" (length: unlimited)>, #<Treequel::Schema::AttributeType:0x69dfa7 seeAlso(2.5.4.34) "RFC4519: DN of related object" SYNTAX: nil (length: unlimited)>, ...]
<?end?>

h3(#schema-otherinfo). Other Schema Information

The Schema object also facilitates access to the directory's "syntaxes and matching rules":http://tools.ietf.org/html/rfc4517 via the <?api Treequel::Schema::LDAPSyntax ?>, <?api Treequel::Schema::MatchingRule ?>, and <?api Treequel::Schema::MatchingRuleUse ?> classes. They are accessed via the @#ldap_syntaxes@, @#matching_rules@, and @#matching_rule_uses@ attributes of the @Schema@, respectively. They, like @#object_classes@ and @#attribute_types@, are Hashes keyed both by OID and names as Symbols.


h2. Real World Examples

h3. Cross-directory Searches


For example, this one-liner finds the first name of all @inetOrgPerson@ classes within the @People@ organizational unit that have a @uid@ that starts with the string "ma":

<?example { language: irb, caption: "Chaining filter methods" } ?>
irb> dir.ou( :people ).filter( :objectClass => 'inetOrgPerson' ).filter( :uid => 'ma*' ).collect {|branch| branch[:givenName].first }.sort
# => ["Mahlon", "Margaret", "Margaret", "Mark", "Marlon", "Matt", "Mike", "Mimi"]
<?end?>



h2. Authors

* Michael Granger
* Mahlon E. Smith


h2. Contributors

A special thanks to Ben Bleything, who was part of the initial brainstorm that
led to the creation of this library.


h2. License

Copyright  2008-2010, Michael Granger and Mahlon E. Smith
All rights reserved.

Redistribution and use in source and binary forms, with or without modification, are
permitted provided that the following conditions are met:

* Redistributions of source code must retain the above copyright notice, this list of
  conditions and the following disclaimer.
* Redistributions in binary form must reproduce the above copyright notice, this list of
  conditions and the following disclaimer in the documentation and/or other materials
  provided with the distribution.
* Neither the name of the authors nor contributors may be used to endorse or promote products
  derived from this software without specific prior written permission.

THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND ANY
EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF
MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE
COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR
TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.

<div id="cc-license">
<a rel="license" href="http://creativecommons.org/licenses/by/3.0/">
	!images/cc-by.png(Creative Commons License)!
</a><br/>
The content of this manual, including images, video, and any example source code is 
licensed under a <a rel="license" href="http://creativecommons.org/licenses/by/3.0/">Creative 
	Commons Attribution 3.0 License</a>.
</div>
